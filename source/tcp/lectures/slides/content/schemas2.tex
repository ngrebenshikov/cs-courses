Хакасский государственный университет им. Н.Ф. Катанова\newline
Теория вычислительных процессов\newline
\title{Лекция: Свойства и моделирование стандартных схем}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Тотальность}

	ССП $S$ в базисе $B$ тотальна, если для любой интерпретации $I$ базиса $В$ программа $(S, I)$ останавливается.

	\textbf{Пустота}

	ССП $S$ в базисе $B$ пуста, если для любой интерпретации $I$ базиса $В$ программа $(S, I)$ зацикливается.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Какая тотальна, какая пуста?}

	\includegraphics[width=1\textwidth]{content/schemas2/total-empty.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Функцианальная эквивалентность}

	Стандартные схемы $S_1$, $S_2$ в базисе $B$ функционально эквивалентны $(S_1 \; \tilde{} \; S_2)$, если либо обе зацикливаются, либо обе останавливаются с одинаковым результатом, т. е. $val(S_1, I) = val(S_2, I)$.

\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Эти схемы эквивалентны?}

	\includegraphics[width=1\textwidth]{content/schemas2/equal.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Цепочкой стандартной схемы (ЦСС)} называют:

	\begin{enumerate}
		\item конечный путь по вершинам схемы, ведущий от начальной вершины к заключительной;
		\item бесконечный путь по вершинам, начинающийся начальной вершиной схемы.
	\end{enumerate}

	В случае, когда вершина-распознаватель $v$, то дополнительно указывается верхний индекс ($1$ или $0$), определяющий $1$-дугу или $0$-дугу, исходящую из вершины.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Примеры цепочек}:
	
	$(0, 1, 2^1, 5); (0, 1, 2^0, 3, 4, 2^0 3, 4, 2^1, 5)$ 

	\includegraphics[width=0.3\textwidth]{content/schemas2/schema_ex1.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Цепочкой операторов (ЦО)} называется последовательность операторов, метящих вершины некоторой цепочки схемы.
	
	Например: $(start(x), y:=a, p_1(x), stop(y))$ или $(start(x), y:=a, p_0(x), y:=g(x, y), x:=h(x), p_0(x), y:=g(x, y), x:=h(x), p_0(x), y:=g(x, y), x:=h(x), …))$ и т. д.

	Предикатные символы ЦО обозначаются так же, как вершины распознавателей в ЦСС.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
Пусть $S$ - ССП в базисе $B$, $I$ - некоторая его интерпретация, $(0, 1, …, l_2, l_3,…)$ - последовательность меток инструкций $S$, выписанных в том порядке, в котором эти метки входят в конфигурации протокола выполнения программы $(S, I)$. Ясно, что эта последовательность – цепочка схемы $S$. Считают, что интерпретация $I$ \textbf{подтверждает (порождает)} эту цепочку.

ЦСС в базисе $В$ называют \textbf{допустимой}, если она подтверждается хотя бы одной интерпретацией этого базиса. 
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Допустимы ли данные ЦСС?}

	$(0, 1, 2^0, 5, 6^1, 7), (0, 1, 2^1, 3, 4^0, 7)$

	\includegraphics[width=0.3\textwidth]{content/schemas2/schema_ex2.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	ССП \textbf{свободна}, если все ее цепочки допустимы.
	
	\textbf{Допустимая цепочка операторов} - это цепочка операторов, соответствующая допустимой цепочке схемы. В тотальной схеме все допустимые цепочки (и допустимые цепочки операторов) конечны. В пустой схеме - бесконечны.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Моделирование стандартных схем программ} с помощью детерминированных конечных автоматов
	
	\begin{itemize}
		\item Одноленточные автоматы
		\item Многоленточные автоматы
		\item \textbf{Двухголовочные автоматы}
	\end{itemize}
\end{slide}
 
% ----------------------------------------------------------------
\begin{slide}
	\textbf{Одноленточные автоматы}
	$A = \{V, Q, R, q_0, \#, I\}$
	
	\textbf{Программа автомата $I$} представляет собой множество команд вида $qa \rightarrow q'$, в которой $q,q' \in Q, a \in V$ и для любой пары $(q, a)$ существует единственная команда, начинающаяся этими символами.
	
	$V$ - алфавит; $Q$ - конечное непустое множество состояний $(Q \bigcap V = \oslash)$; $R$ - множество выделенных заключительных состояний $(R \subseteq Q)$; 
	$q_0$ - выделенное начальное состояние; $I$ - программа автомата; $\#$ - «пустой» символ. 
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Какие слова допускает этот одноленточный автомат?}

	$A = (\{a, b\}, \{q_0, q_1, q_2, q_3\}, \{q_2\}, q_0, \#, I)$
	
	$I = \{q_0a \rightarrow q_1; q_0b \rightarrow q_3; q_1a \rightarrow q_1; q_1b \rightarrow q_2; q_2a \rightarrow q_3; q_2b \rightarrow q_2; q_3a \rightarrow q_3; q_3b \rightarrow q_3\}$

	\includegraphics[width=0.5\textwidth]{content/schemas2/ofa_ex.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Свойства одноленточных автоматов}
	
	Автомат называется \textbf{пустым}, если $M_A = \oslash$.
	
	Автоматы $A_1$ и $A_2$ эквивалентны, если $M_{A_1} = M_{A_2}$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Свойства одноленточных автоматов}
	
\begin{itemize}
	\item \textit{Проблема пустоты ОКА разрешима.}\newline
	Доказательство основано на проверке допустимости конечного множества всех слов, длина которых не превышает числа состояний ОКА - $n$. Если ни одно слово из этого множества не допускается, то ОКА «пуст».
	\item Предположение о том, что минимальная длина допускаемого слова больше $n$ отвергается на том основании, что оно может быть сведено к слову меньшей длины, путем выбрасывания участков между двумя повторяющимися в пути узлами.
	\item \textit{Проблема эквивалентности ОКА разрешима.}\newline
	Доказательство основано на использовании отношения эквивалентности двух состояний $q$ и $q'$: если состояния $q$ и $q'$ эквивалентны, то для всех $a \in A$ состояния $d(q, a)$ и $d'(q', a)$ также эквивалентны. Формируемые пары не должны входить одновременно заключительное и незаключительное состояния.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Многоленточный автомат} определяется как и ОКА.
	
	Отличие: множество состояний $Q$ разбивается на $n$ подмножеств (непересекающихся) $Q_1, ..., Q_n$.
	
	Физическая интерпретация: он имеет $n$ лент и $n$ головок, по головке на ленту.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Какое множество строк допускает этот автомат?}

	$Q = Q_1 \bigcup Q_2$, где $Q_1={q_0^1}; Q_2={q_1^2, q_2^2, q_3^2}; R={q_0^1}; V={0, 1}$, начальное состояние - $q_0^1$. 

	МКА обрабатывает наборы слов $(U_1, U_2)$, где слово $U_1$ записано на первой ленте, а $U_2$ - на второй.
	
	\includegraphics[width=0.3\textwidth]{content/schemas2/mfa_ex.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Свойство многоленточных автоматов}

	Доказана разрешимость проблемы эквивалентности двухленточных автоматов.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Двухголовочные автоматы. Почему?}

	Проблема пустоты разрешима для многоленточных автоматов и неразрешима для многоголовочных.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Двухголовочный автомат (ДКА)} имеет одну ленту и две головки, которые могут независимо перемещаться вдоль ленты в одном направлении. 
	
	Множество состояний $Q$ разбито на два непересекающихся множества. В состояниях $Q_1$ активна первая головка, а в состояниях $Q_2$ - вторая.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Двухголовочный автомат}
	
\begin{center}
\includegraphics[width=0.32\textwidth]{content/schemas2/dhfa_ex.png}
\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Свойства двухголовочного автомата}
	
\begin{itemize}
	\item Лемма (Розенберг). Существует алгоритм, который для любой машины Тьюринга и для любого начального слова строит двухголовочный автомат, моделирующий ее работу над этим словом.
	\item Теорема. Проблема пустоты ДКА не является частично разрешимой.
	\item Теорема. Проблема эквивалентности ДКА не является частично разрешимой.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Двоичный двухголовочный автомат} - двухголовочный автомат, где $V = \{0,1\}$.
	
	Cтандартные схемы могут моделировать двухголовочные автоматы, что позволяет свести проблему пустоты этих автоматов к проблеме пустоты схем.
	
	\textit{Лемма.} Существует алгоритм преобразования двухголовочных автоматов в двоичные двухголовочные автоматы (ДДКА), сохраняющий пустоту автоматов (построенный двоичный автомат $A_b$ пуст тогда и только тогда, когда пуст исходный автомат $A$).
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Двоичный двухголовочный автомат} - двухголовочный автомат, где $V = \{0,1\}$.
	
	Cтандартные схемы могут моделировать двухголовочные автоматы, что позволяет свести проблему пустоты этих автоматов к проблеме пустоты схем.
	
	\textit{Лемма.} Существует алгоритм преобразования двухголовочных автоматов в двоичные двухголовочные автоматы (ДДКА), сохраняющий пустоту автоматов (построенный двоичный автомат $A_b$ пуст тогда и только тогда, когда пуст исходный автомат $A$).
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Доказательство}

Пусть ДКА $A$ над алфавитом $V = \{a_1, a_2, ..., a_n\}$ имеет множество состояний  $Q_A = \{q_1^k, q_2^k, …, q_k^k\}$, где верхний индекс $k = 1, 2$ определяет номер активной головки. Преобразование этого автомата в двоичный начнем с кодировки символов и слов из $V*$ словами в алфавите $\{0, 1\}$ по следующему правилу:

код $(\#) = 0$;

код $(a_i)$ = $11....10 (i = 1, …, n)$;

код $(a_a^i) = $код$ (a) $код$ (a_i)$.	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Доказательство}

Так как символ $\#$ кодируется нулем, то любому непустому слову на ленте автомата $A$ соответствует двоичное слово на ленте автомата $A_b$, оканчивающееся двумя нулями. 
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Доказательство}

Множество состояний автомата $A_b$ включает:

а) все старые состояния из $Q_A$;

б) для каждого старого состояния $q_j^k$  $n$ новых состояний, $n$ - число символов алфавита $V$;

в) два новых состояния $r_1^1$ и $r_2^1$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Доказательство}

	В граф $А_b$ вводятся вершины $S_a$ (останов допускающий) и $S_r$ (останов отвергающий).
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример}
	
	\begin{center}
	\includegraphics[width=0.6\textwidth]{content/schemas2/bdhfa_ex.png}
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Принципы преобразования}
	
	\begin{center}
	\includegraphics[width=0.75\textwidth]{content/schemas2/bdhfa_ex_2.png}
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Польза двоичного двухголовочного автомата}
	
	По заданному ДДКА можно построить ССП и наоборот, что позволяет решить задачу разрешимости (не разрешимости) свойств ССП, так как эта задача решена ДДКА решена.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Построение схемы моделирующей автомат}
	
	Двоичное слово $b_1 b_2 \ldots b_n$ согласовано с свободной интерпретацией базиса $B$, если для любого $ 1 \leq i \leq n, I(p)('f^ia')=b_i$, где $p$ - единственный предикатный символ.

	\begin{center}
	\includegraphics[width=1\textwidth]{content/schemas2/transform_ex.png}
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Построение схемы моделирующей автомат}
	
	Если на ленту автомата $A$ подано произвольное двоичное слово $a$, то программа $(S,I)$, где $I$ - любая свободная интерпретация базиса $B$, согласованная с $a$, останавливается в том и только в том случае, когда автомат допускает слово $a$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Основные теоремы}
	
Лемма. ДДКА пуст в том и только в том случае, если пуста моделирующая его стандартная схема.

Лемма. Для любого ДДКА можно построить моделирующую его стандартную схему.

Теорема (Лакхэм - Парк - Патерсон). Проблема пустоты стандартных схем не является частично разрешимой.

Теорема (Лакхэм - Парк - Патерсон, Летичевский). Проблема функциональной эквивалентности стандартных схем не является частично разрешимой.

Теорема (Лакхэм - Парк - Патерсон). Проблема тотальности стандартных схем частично разрешима.

Теорема (Патерсон). Проблема свободы стандартных схем не является частично разрешимой.	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Рабинович Е.В. Теория вычислительных процессов. \textbf{Разделы ``Свойства и виды стандартных схем программ '' и ``Моделирование стандартных схем программ ''}.
	\item Котов В.Е., Сабельфельд В.К. Теория схем программ. - М.: Наука, 1991. - 248 с. \textbf{сс.83-110}.
\end{itemize}
\end{slide}

