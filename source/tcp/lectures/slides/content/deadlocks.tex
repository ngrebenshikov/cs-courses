Хакасский государственный университет им. Н.Ф. Катанова\newline
Теория вычислительных процессов\newline
\title{Лекция: Взаимоблокировки (тупики, deadlocks)}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Взаимоблокировка}
	
	Группа процессов находится в тупиковой ситуации, если каждый процесс из группы ожидает события, которое может вызвать только другой процесс той же группы.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Области возникновения блокировок}
	
\begin{itemize}
	\item Аппаратная часть. Например, разделяемые устройства ввода-вывода.
	\item Программное обеспечение. Операционные системы, базы данных.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Обобщение: ресурсы}
	
\begin{itemize}
	\item Выгружаемые - можно безболезненно забрать у владельца. Например, память.
	\item Невыгружаемые. Например, устройства записи на DVD$\pm$R.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Жизненный цикл ресурса}
	
\begin{enumerate}
	\item Запрос ресурса
	\item Использование ресурса
	\item Возврат ресурса
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Защита ресурсов}

	\begin{center}
		\includegraphics[height=0.85\textheight]{content/deadlocks/resources_guarding.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Условия взаимоблокировки} (Коффман)

\begin{enumerate}
	\item Условие взаимного исключения.
	\item Условие удержания и ожидания.
	\item Условие отсутствия принудительной выгрузки ресурса.
	\item Условие циклического ожидания.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Модель Холта}

	\begin{center}
		\includegraphics[height=0.4\textheight]{content/deadlocks/holt_model.png}	
	\end{center}
	
	Квадрат - ресурс, круг - процесс.
	
	Ребро от ресурса к процессу означает, что процесс использует ресурс.
	
	Ребро от процесса к ресурсу означает, что процесс запрашивает (ожидает) ресурс.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Модель с возможной взаимоблокировкой}

	\begin{center}
		\includegraphics[height=0.85\textheight]{content/deadlocks/holt_deadlock.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Модель с возможной взаимоблокировкой}

	\begin{center}
		\includegraphics[height=0.85\textheight]{content/deadlocks/holt_without_deadlock.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Стратегии управления взаимоблокировками}
\begin{enumerate}
	\item Пренебрежение проблемой.
	\item Обнаружение и восстановление.
	\item Динамическое избежание тупиковых ситуаций с помощью аккуратного распределения ресурсов.
	\item Предотвращение с помощью структурного опровержения одного из условий, необходимых для взаимоблокировки.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Страуссовый алгоритм}
	
	Математики - тупики не приемлимы!
	
	Инженеры - как часто они случаются? Нечасто, значит никогда.
	
	Возможные причины тупиков в ОС: таблица процессов, таблица файлов, файл подкачки.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Обнаружение взаимоблокировок (один ресурс каждого типа)}

	Заблокирована ли система, если да, то какие процессы в этом участвуют?

	\begin{center}
		\includegraphics[height=0.6\textheight]{content/deadlocks/deadlock_detection.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм}
\begin{enumerate}
	\item Выполнить \textbf{шаги 2-6} для каждого узла в графе.
	\item $L$ - пустой список. Все ребра немаркированы.
	\item $L.Add($текущий узел$)$. Если узел содержится в списке дважды, то граф имеет цикл и работа заершается.
	\item Если из текущего узла выходит не маркированное ребро, то \textbf{шаг 5}, иначе \textbf{шаг 6}.
	\item Выбираем любое немаркированное исходящее ребро, переходим по нему к новому узлу и \textbf{шаг 3}.
	\item Удаляем последний узел из списка и возвращаемся к предыдущему узлу. Если это первоначальный узел, то в графе нет циклов, иначе \textbf{шаг 3}.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Обнаружение взаимоблокировок (несколько ресурсов каждого типа)}

	$P_1, P_2, \ldots, P_n$ - процессы.
	
	$E = (E_1, E_2, \ldots, E_m)$ - вектор существующих ресурсов, где $E_i$ - число ресурсов класса $i$.

	$A = (A_1, A_2, \ldots, A_m)$ - вектор доступных ресурсов.
	
	$C = 
	\begin{bmatrix}
		C_{11} & C_{12} & \ldots & C_{1m} \\
		C_{21} & C_{22} & \ldots & C_{2m} \\
		\vdots & \vdots & \vdots & \vdots \\
		C_{n1} & C_{n2} & \ldots & C_{nm} \\
	\end{bmatrix}$ - матрица текущего распределения.
	
	$C_{ij}$ - количество экземпляров ресурса $j$ использует $i$-й процесс.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Обнаружение взаимоблокировок (несколько ресурсов каждого типа)}

	$R = 
	\begin{bmatrix}
		R_{11} & R_{12} & \ldots & R_{1m} \\
		R_{21} & R_{22} & \ldots & R_{2m} \\
		\vdots & \vdots & \vdots & \vdots \\
		R_{n1} & R_{n2} & \ldots & R_{nm} \\
	\end{bmatrix}$ - матрица запросов.
	
	$R_{ij}$ - количество экземпляров ресурса $j$ запрашивает $i$-й процесс.
	
	Инвариант системы: $\displaystyle \sum_{i=1}^{n}{C_{ij}} + A_j = E_j$
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм}

	Пусть $A \leq B \Leftrightarrow A_i \leq B_i, 1 \leq i \leq m$, где $A$ и $B$	- вектора.
	
	
\begin{enumerate}
	\item Ищем немаркированный $P_i$, что $R_i \leq A$, если найден \textbf{шаг 2}, иначе \textbf{шаг 3}.
	\item $A = A + C_i$, маркируем $P_i$, \textbf{шаг 1}.
	\item Работа завершена, все немаркированные процессы в тупике.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Обнаружение взаимоблокировок (несколько ресурсов каждого типа)}

	\begin{center}
		\includegraphics[height=0.7\textheight]{content/deadlocks/deadlock_detection_example.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Выход из взаимоблокировки}
	
	Нашли! Что дальше?
\begin{itemize}
	\item Принудительная выгрузка ресурса. (Вручную или автоматически)
	\item Откат. (Контрольные точки)
	\item Уничтожение процессов. (Выбор жертвы)
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Избежание взаимоблокировок}
	
\begin{itemize}
	\item Траектории ресурсов
	\item Безопасные и небезопасные состояния
	\item Алгоритм банкира (один вид ресурсов, несколько видов ресурсов)
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Траектории ресурсов}

	\begin{center}
		\includegraphics[height=0.8\textheight]{content/deadlocks/resources_path.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Безопасное состояние} - процессы находятся не в тупике, и существует некоторый порядок планирования, при котором каждый процесс может работать до завершения,
	даже если все процессы вдруг захотят немедленно получить свое максимальное количество ресурсов.

	\begin{center}
		\includegraphics[height=0.4\textheight]{content/deadlocks/safe_states.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Небезопасное состояние}

	\begin{center}
		\includegraphics[height=0.6\textheight]{content/deadlocks/unsafe_states.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм банкира}
	
	Удовлетворять запрос процесса на получение ресурсов только в том, случае если состояние системы после выделения ресурсов будет безопасным.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм банкира}
	
	\begin{center}
		\includegraphics[height=0.7\textheight]{content/deadlocks/banker.png}	
	\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм банкира}

	\begin{enumerate}
		\item Ищем $R_i \leq A$. Если нашли \textbf{шаг 2}, иначе \textbf{состояние небезопасное}.
		\item $A = A + R_i$, $R_i$ помечаем как завершенный.
		\item Повторяем шаги 1-2 пока не пометим все процессы как завершенные.
	\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Предотвращение взаимоблокировок. Атаки на условия возникновения.}

	\begin{enumerate}
		\item Взаимное исключение - организовать подкачку данных.
		\item Удержание и ожидание - запрашивать все ресурсы сразу на начальной стадии.
		\item Нет принудительной выгрузки процесса - отобрать ресурсы.
		\item Циклическое ожидание - пронумеровать ресурсы и упорядочить.
	\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Таненбаум Э. Современные операционные системы. 2-е изд. - СПб.: Питер, 2002. - \textbf{сc.184-216}
\end{itemize}
\end{slide}