Хакасский государственный университет им. Н.Ф. Катанова\newline
Теория вычислительных процессов\newline
\title{Лекция: Верификация программ.}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Как убедиться в том, что ошибки в программе отсутствуют?}
	
	\textbf{Неформальные методы:}
	
	\begin{itemize}
		\item Отладка - контрольные распечатки, трассировки.
		\item Тестирование – процесс выполнения программы с намерением найти ошибку, а не подтвердить правильность программы.
	\end{itemize}
	
	\textbf{Верификация программ} - метод установления правильности программ при помощи строгих средств.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Верификация} проверяет свойства программы.
	
	 То есть отвечает на вопрос \newline \textbf{``Удовлетворяет ли программа документации?''}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Документация программы}
	
	\begin{itemize}
		\item спецификация ввода-вывода (описание данных, не зависящих от процесса обработки);
		\item свойства отношений между элементами векторов состояний в выбранных точках программы;
		\item спецификации и свойства структурных подкомпонентов программы;
		\item спецификацию структур данных, зависящих от процесса обработки.
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Метод индуктивных высказываний, сформулированный К. Флойдом и П. Науром}
	
	\begin{itemize}
		\item формулируются входное и выходное высказывания: входное высказывание описывает все необходимые входные условия для программы (или программного фрагмента), выходное высказывание описывает ожидаемый результат;
		\item предполагая истинным входное высказывание, строится промежуточное высказывание, которое выводится на основании семантики операторов, расположенных между входом и выходом (входным и выходным высказываниями); такое высказывание называется выведенным высказыванием;
		\item формулируется теорема (условия верификации): из выведенного высказывания следует выходное высказывание;
		\item доказывается теорема; доказательство свидетельствует о правильности программы (программного фрагмента).
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм доказательства по методу индуктивных высказываний}
	
\begin{enumerate}
	\item Построить структуру программы.
	\item Выписать входное и выходное высказывания.
	\item Сформулировать для всех циклов индуктивные высказывания.
	\item Составить список выделенных путей.
	\item Построить условия верификации.
	\item Доказать условие верификации.
	\item Доказать, что выполнение программы закончится.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Недостатки метода индуктивных высказываний}
	
	\begin{itemize}
		\item Необходимо аксиоматическое описание языка программирования. Возникают свойственные трудности с множеством аксиом.
		\item Если задача, для которой пишется программа, не имеет строгого математического описания, то для нее сложно сформулировать условия верификации.
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Триада Хоара} - использование высказываний в программах.
	
	Программа вместе с высказываниями между каждой парой соседних операторов называется наброском доказательства. 
	
	Последовательно, для каждого оператора программы формулируя предикат, можно доказать, что программа удовлетворяет своим спецификациям.	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Высказывания в программах.} Пример 1. 
	
	$\{Q\} S \{R\}$
	
	$R: s \times s \leq n (s+1)\times(s+1)$
	
	$S: s = sqrt(n)$, где $n,s \in N$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Высказывания в программах.} Пример 2. 
	
	$\{Q\} S \{R\}$
	
	$Q: n > 0 \wedge a[1..n]$ - массив

	$R: 1 \leq i < n \Rightarrow a[i] \leq a[i+1]$
	
	Что должна делать $S$?
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Высказывания в программах.} Пример 3. 
	
	$\{Q\} S \{R\}$
	
	$Q: n > 0 \wedge a[1..n]$ - массив целых чисел, $x$ - целое число

	$R: 1 \leq i \leq n \Rightarrow x \geq a[i] \wedge \exists j:1 \leq i \leq n \ x = a[j]$
	
	Что должна делать $S$?
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Высказывания в программах.} Пример 3. 
	
	$\{a = A AND b = B\} S \{a = B AND b = A\}$
	
	Что должна делать $S$?
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Правила (аксиомы) К.Хоара} 
	
	Чтобы использовать высказывания для доказательства правильности программы, необходимы соответствующие правила верификации.
	
	Правила Хоара определяют предусловия как достаточные предусловия, гарантирующие, что исполнение соответствующего оператора при успешном завершении приведет к желаемым постусловиям.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{А1. Аксиома присваивания}
	
	$\{R_{x \rightarrow E}\} \ x = E \ \{R\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Аксиомы монотонности}
	
	A2. Если известно: $\{Q\} S \{P\}$ и $\{P\} \Rightarrow \{R\}$, то $\{Q\} S \{R\}$.
	
	A3. Если известно: $\{Q\} S \{P\}$ и $\{R\} \Rightarrow \{Q\}$, то $\{R\} S \{P\}$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{А4. Аксиома для последовательности программ}
	
	Если известно:$\{Q\} S1 \{P1\}$ и $\{P1\} S2 \{R\}$, то $\{Q\} S \{R\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{А5. Аксиома для условного оператора}
	
	Если известно:$\{Q \wedge B\} S1 \{R\} \wedge \{Q \wedge \neg B\} \Rightarrow \{R\}$, 
	
	то $\{Q\} \ if \ B \ then \ S1 \ \{R\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{А6. Аксиома для условного оператора}
	
	Если известно: $\{Q \wedge B\} S1 \{R\} \wedge \{Q \wedge \neg B\} S2 \{R\}$, 
	
	то $\{Q\} \ if \ B \ then \ S1 \ else \ S2 \ \{R\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{А7. Аксиома для цикла until}
	
	Если известно: $\{Q \wedge \neg B\} S1 \{Q\}$, 
	
	то $\{Q\} \ repeat \ S1 \ until \ B \ \{Q \wedge B\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{А8. Аксиома для цикла while}
	
	Если известно: $\{Q \wedge B\} S1 \{Q\}$, 
	
	то $\{Q\} \ while \ B \ do \ S1 \ \{Q \wedge \neg B\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример верификациии}

	Задача: определить частное $q$ и остаток $r$ от деления $x$ на $y$. Входные данные $x$, $y$ и выходные данные $q, r \in N$, причем $y > 0$.
	
r := x; q := 0; \newline
\textbf{while} $y \leq r$ \textbf{do} \newline
\textbf{begin} \newline
	r := r - y; q := q + 1 \newline
\textbf{end};\newline
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример верификациии}

	Постусловие: $R: (r < y) \wedge (x = y*q + r)$.
	
	Нужно доказать: $\{y > 0\} \ S \ \{(r < y) \wedge (x = y*q + r)\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример верификациии}

	1. $Q \Rightarrow x = x + y \times 0$
	
	2. (A1) $\{x = x + y*0 \} \ r := x \ \{x = r + y*0\}$
	
	3. (A1) $\{x = r + y*0\} \ q  := 0 \ \{x = r + y*q\}$
	
	4. (A3 к 1,2) $\{Q\} \ r := x \ \{x = r + y*0\}$
	
	5. (A4 к 3,4) $\{Q\} \ r := x; \ q := 0 \ \{x = r + y*q\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример верификациии}

	6. $x = r + y*q \wedge y \leq r \Rightarrow q = (r - y) + y*(q + 1)$
	
	7. (A1) $\{x  = (r - y) + y*(q + 1)\} \ r := r - y \ \{x = r+ y*(q+1)\}$
	
	8. (A1) $\{x = r + y*(q  + 1)\} \ q := q + 1 \ \{x = r + y*q\}$
	
	9. (A4 к 7,8) $\{x = (r - y) + y*(q + 1)\} \ r := r - y; \ q := q + 1 \ \{x = r + y*q\}$
	
	10. (A2 к 6,9) $\{x = r + y*q \wedge y \leq r\} \ r := r - y; q := q + 1 \ \{x = r + y*q\}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример верификациии}

	11. (A8 к 10) $\{x = r + y*q\} \ while  \ y \leq r \ do \ begin \ r := r - y; \ q := q + 1 \ end
\{\neg (y \leq r) \wedge (x = r + y*q)\}$
	
	12. (A4 к 5,11) $\{Q\} \ S \ \{\neg (y \leq r) \wedge (x = r + y*q)\}$
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример верификациии}

	Докажем, что программа завершится.
	
	Пусть программа не останавливается, тогда $\exists$ бесконечная последовательность $q,r : y \leq r \wedge r,q \in N$.
	
	Но на каждом шаге цикла $r$ уменьшается $r := r - y (y > 0)$, значит найдется $r < y$ и цикл завершится.
	
	\textbf{Доказательство правильности программы завершено}. 
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Рабинович Е.В. Теория вычислительных процессов. \textbf{Раздел ``Верификация программ''}.
	\item Грис Д. Наука программирования. - М.: Мир, 1984.
\end{itemize}
\end{slide}
