Хакасский государственный университет им. Н.Ф. Катанова\newline
Теория вычислительных процессов\newline
\title{Лекция: Схемы программ: алгоритмические проблемы, стандартные схемы}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Вычислимость}

	\textbf{Вычислимая функция} - функция, которой можно задать способ ее вычисления. (формула, алгоритм).
	
	\textbf{Машина Тьюринга} - абстрактная математическая машина.
	
	\textbf{Тезис Тьюринга:} для каждой функции, для которой существует алгоритм нахождения ее значения, может быть построена машина Тьюринга.
	
	Эмпирический термин алгоритм $\Rightarrow$ Тезиз не доказан! 
	
	Но опровергающие примеры также отсутствуют.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Машина Тьюринга} - словарная функция:
	
\begin{itemize}
	\item $V$ - алфавит;
	\item $Q$ — конечное непустое множество символов, называемых состояниями машины $(Q \bigcap V = \oslash)$;
	\item $q_0$ — выделенный элемент множества Q, называемый начальным состоянием;
	\item $\#$ — специальный «пустой» символ, не принадлежащий ни V, ни Q;
	\item $I$ — программа машины.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Программа машины Тьюринга} - конечное множество команд.
	
	Команда: $qa \rightarrow q'a'd$, где $q,q' \in Q, a,a' \in V \bigcup \{\#\}; \rightarrow$ — вспомогательный символ-разделитель; $d$ — элемент множества $\{l, r, р\}$.
	
	Никакие две команды не могут иметь одинаковую пару первых двух символов!
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Машина Тьюринга}
	
	\includegraphics[width=1\textwidth]{content/schemas1/turing_machine.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Работа машины Тьюринга}
	
\begin{enumerate}
	\item считывание символа, находящегося против головки;
	\item поиск команды $qa \rightarrow q'a'd$, в которой $q$ — текущее состояние, $а$ — считанный символ;
	\item выполнение команды
\end{enumerate}

Машина останавливается в том и только в том случае, если на очередном шаге ни одна из команд не применима. 

\textbf{Результат работы} — заключительное слово на ленте остановившейся машины.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Свойства машины Тьюринга} 
\begin{enumerate}
\item \textbf{конструктивность} — МТ есть конечный объект, построенный по определенным правилам из базовых объектов;
\item \textbf{конечность} — нахождение значений для значений аргументов, для которых она определена, состоит из конечного числа шагов;
\item \textbf{однозначность} — результат единственным образом определяется начальным словом;
\item \textbf{массовость} — машина работает с любым начальным словом, составленным из символов ее алфавита.	
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Автоматизация программирования} - одна из целей изучения теоретического программирования. 

	\textbf{Алгоритмические проблемы:}
	
\begin{itemize}
	\item узнать будет ли программа работать бесконечно;
	\item дают ли две программы одинаковый результат;
	\item является ли программа синтаксически правильной;
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритмическая проблема, как проблема принадлежности множеству.} Разрешимость. Перечислимость.
	
	Пусть $V$ – алфавит, $M \subseteq V$ – множество слов в $V$.

\textit{Характеристическая функция множества $M$:} \newline $F_M: V^* \rightarrow \{0, 1\}$, всюду определенный на $V^*: F_M(a) = 1$, если $a \in M$, и $F_M(a) = 0$, если $a \notin M$.

\textit{Частичная характеристическая функция множества $M$:} \newline $H_M: V^* \rightarrow \{1\}$, определенная только для слов из $M$ и имеющая вид $H_M(a) = 1$ для всех $a \in M$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Важные теоремы}
\begin{enumerate}
	\item Множество $M \subseteq V^*$ разрешимо тогда и только тогда, когда $M$ и его дополнение $M' = V^* \backslash M$ перечислимы.
	\item Проблема остановки машины Тьюринга неразрешима.
	\item Проблема зацикливания машины Тьюринга не является частично разрешимой.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Универсальная машина Тьюринга} © 2003 Jin Wicked, USA.
	
	\includegraphics[width=0.4\textwidth]{content/schemas1/turing.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Схема программы} - математическая модель программы, описывающая строение программы, или точнее строение множества программ, где конкретные операции и функции заменены абстрактными функциональными и предикатными символами.
	
	\includegraphics[width=1\textwidth]{content/schemas1/schema_vs_progs.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Классы схемы программ}
	
\begin{itemize}
	\item Стандартные
	\item Рекурсивные
	\item Обогащенные
	\item Структурированные
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Стандартные схемы программ} - характеризуются \textit{базисом} и \textit{структурой}.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Базис стандартных схем}
	
\begin{itemize}
	\item Переменные - $X = \{x, x_1, x_2, \ldots, y, y_1, y_2, \ldots, z, z_1, z_2, \ldots\} $
	\item Функциональные символы - \newline $F = \{f^{(0)}, f^{(1)}, f^{(2)}, \ldots, g^{(0)}, g^{(1)}, g^{(2)}, \ldots, f^{(0)}, h^{(1)}, h^{(2)}, \ldots \}$. $f^{0},g^{0},h^{0},\ldots$ - константы, и обозначаются $a,b,c,\ldots$ 
	\item Предикатные символы - $P = \{p^{(0)}, p^{(1)}, p^{(2)}, \ldots, q^{(0)}, q^{(1)}, q^{(2)}\}$. $p^{0},q^{0},\ldots$ - логические константы. 
	\item Специальные символы - $\{start, stop, \ldots \}$
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Базис стандартных схем.} Термы.\newline	
	\textit{Термы (функциональные выражения)} - слова, построенные из переменных, функциональных и специальных символов по следующим правилам:
	
\begin{itemize}
	\item односимвольные слова, состоящие из переменных или констант, являются термами;
	\item слово $\tau$ вида $f^{(n)}(\tau_1, \tau_2, \ldots, \tau_n)$, где $\tau_1, \tau_2, \ldots, \tau_n$  - термы, является термом;
	\item те и только те слова, о которых говорится в п.п. 1,2, являются термами.
\end{itemize}

Примеры термов: $х, f:{(0)}, а, f^{(1)}(х), g^{(2)}(x, h^{(2)}(y, a))$.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Базис стандартных схем.} Тесты.

	\textit{Тесты (логические выражения)} логические константы и слова вида $p^{(n)}(\tau_1, \tau_2,\ldots, \tau_n)$. 
	
	Примеры: $p^{(0)}, p^{(1)}(x), q^{(3)}(x, y, z), p^{(1)}(f^{(2)}(x, y))$. 
	
	Допускается в функциональных и логических выражениях опускать индексы местности, если это не приводит к двусмысленности или противоречию.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Базис стандартных схем.} Операторы.
\begin{itemize}
	\item \textit{начальный оператор} - слово вида $start(x_1, x_2, \ldots, x_k)$, где $k \geq 0$, а $x_1, x_2, \ldots, x_k$ - переменные, называемые результатом этого оператора;
	\item \textit{заключительный оператор} - слово вида $stop(\tau_1, \tau_2, \ldots, \tau_n)$, где $n \geq 0$, а $\tau_1, \tau_2,\ldots , \tau_n$ - термы; вхождения переменных в термы $\tau$ называются аргументами этого оператора; 
	\item \textit{оператор присваивания} - слово вида $x := \tau$, где $x$ – переменная (результат оператора), а $\tau$ - терм; вхождения переменных в термы называются аргументами этого оператора; 
	\item \textit{условный оператор (тест)} - логическое выражение; вхождения переменных в логическое выражение называются аргументами этого оператора; 
	\item \textit{оператор петли} - односимвольное слово $loop$. 
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример базиса стандартных схем}
	
	Подкласс $V1$
	
	$\{x_1, x_2\}, \{a, f^{(1)}\}, \{p^{(1)}\}, \{start, stop,(, ), :=, ,\}, $
	
	$\{start(x_1, x_2); x_1:=f(x_1), x_2:=f(x_2), $
	
	$x_1:=a, x_2:= a, p(х_1), p(x_2), stop(x_1, x_2)\}$
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Структура стандартной схемы.} Графовое представление.
	
	Стандартной схемой в базисе В - конечный размеченный ориентированный граф без свободных дуг и с вершинами следующих пяти видов:
	
	
\begin{enumerate}
	\item \textit{Начальная вершина} (ровно одна) помечена начальным оператором. Из нее выходит ровно одна дуга. Нет дуг, ведущих к начальной вершине.
	\item \textit{Заключительная вершина} (может быть несколько). Помечена заключительным оператором. Из нее не выходит ни одной дуги.
	\item \textit{Вершина-преобразователь}. Помечена оператором присваивания. Из нее выходит ровно одна дуга.
	\item \textit{Вершина-распознаватель}. Помечена условным оператором (называемым условием данной вершины). Из нее выходит ровно две дуги, помеченные 1 (левая) и 0 (правая).
	\item \textit{Вершина-петля}. Помечена оператором петли. Из нее не выходит ни одной дуги.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Структура стандартной схемы.} Графовое представление.
	
	\includegraphics[width=0.9\textwidth]{content/schemas1/standard_scheme_example1.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Структура стандартной схемы.} Графовое представление.
	
	\includegraphics[width=0.5\textwidth]{content/schemas1/standard_scheme_example2.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Структура стандартной схемы.} Линейная форма.

	Множество операторов необходимо расширить $\{goto, if, then, else\}$

0:       start(х) goto 1, \newline
1:       у:=а goto 2,     \newline
2:       if  р(х) then 5 else 3,   \newline
3:       у:=g(x,y) goto 4, \newline
4:       х:=h(x) goto 2, \newline
5:       stop(у). \newline
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Структура стандартной схемы.} Сокращенная линейная форма.

start(х), \newline
у:=а,     \newline
\textbf{2:}       if  р(х) then 5 else 3,   \newline
\textbf{3:}       у:=g(x,y), \newline
х:=h(x) goto 2, \newline
\textbf{5:}       stop(у). \newline
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Интерпретация стандартной схемы} c базисом $B$ в области интерпретации $D$ называется функция $I$, которая сопоставляет:
	
\begin{enumerate}
	\item каждой переменной $x$ из базиса $B$ - некоторый элемент $d = I(x)$ из области интерпретации $D$;
	\item каждой константе $a$ из базиса $B$ - некоторый элемент $d = I(a)$ из области интерпретации $D$;
	\item каждому функциональному символу $f^{(n)}$ - всюду определенную функцию $F^{(n)} = I(f^{(n)})$;
	\item каждой логической константе $p^{(0)}$ - один символ множества $\{0,1\}$;
	\item каждому предикатному символу $p^{(n)}$ - всюду определенный предикат $P^{(n)} = I(p^{(n)})$.
\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Стандартная программа} - пара $(S,I)$, где $S$ - стандартная схема, а $I$ ее интерпертация.
	
	\textit{Память схемы} $X_S$ конечное множество переменных схемы S. 
	
	\textit{Состоянием памяти} программы $(S,I)$ называют функцию $W: X_S \rightarrow D$, которая каждой переменной $x$ из памяти схемы $S$ сопоставляет элемент $W(x)$ из области
	интерпретации $D$. 
	
	\textit{Значение терма} $\tau$ при интерпретации $I$ и состоянии памяти $W$ (обозначим $\tau_I(W)$) определяется следующим образом:
\begin{itemize}
	\item если $\tau = x$, $x$ – переменная, то $\tau_I(W) = W(x)$;
	\item если $\tau = a$, a – константа, то $\tau_I(W) = I(a)$;
	\item если $\tau = f^{(n)}(\tau_1, \tau_2,\ldots , \tau_n)$, то \newline $\tau_I(W) = I(f^{(n)})(\tau_{1I}(W), \tau_{2I}(W), \ldots , \tau_{nI}(W))$;
	\item если $p = р(n)(\tau_1, \tau_2, \ldots, \tau_n)$, то \newline $p_I(W) = I(p^{(n)})(\tau_{1I}(W), \tau_{2I}(W),... \tau_{nI}(W)), n \geq 0$
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Выполнение стандартной программы}
	
	\textit{Конфигурация программы} - пара $U = (L,W)$, где $L$ - метка вершины схемы $S$, а $W$ - состояние ее памяти. 
	
	\textit{протоколом выполнения программы} (ПВП) - конечная или бесконечная последовательность конфигураций \newline $(U_0, U_1,\ldots, U_i, U_{i+1},\ldots)$ выполнения программы $(S,I)$
	
	$U0 = (0, W_0)$, $W_0$ – начальное состояние памяти схемы $S$ при интерпретации $I$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Выполнение стандартной программы}
Пусть $U_i = (k_i, W_i)$ - $i$-я конфигурация ПВП, а $O$ - оператор схемы $S$ в вершине с меткой $k_i$, тогда $U_{i+1} = (k_{i+1}, W_{i+1})$

\begin{itemize}
	\item $O = start(\tau_1,\ldots, \tau_n)$ и следующая вершина с меткой $L$, то $k_{i+1} = L$ и $W_{i+1} = W_i$;
	\item $O = x := \tau$ и следующая вершина с меткой L, то $k_{i+1} = L, W_{i+1} = W_i, W_{i+1}(x) = \tau_I(W_i)$;
	\item $O$ - условный оператор $p$ и $p_I(W_i) = \Delta$, где $\Delta \in \{0,1\}$и следующая вершина с меткой L, то $k_{i+1} = L$ и $W_{i+1} = W_i$;
	\item $O$ - оператор петли, то $k_{i+1} = k_i$ и $W_{i+1} = W_i$, так что протокол бесконечен.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Результат выполнения стандартной программы} $val(S,I)$ выполнения программы $(S,I)$ - последовательность значений $\tau_{1I}(W), \tau_{2I}(W),\ldots, \tau_{nI}(W)$ из последней конфигурации протоколе, где $O = stop(\tau_1, \tau_2, \dots \tau_m)$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Пример интерпретации}
	
	$I_1(x)=4; I_1(y)=0; I_1(a)=1;$

	$I_1(g)=G$, где $G$ - функция умножения чисел, т. е. $G(d_1,d_2)= d_1*d_2$;

	$I_1(h)=H$, где $H$ - функция вычитания единицы, т. е. $H(d)= d - 1$;

	$I_1(p)=P1$, где $P_1$ - предикат «равно 0», т.е. $P_1(d)=1$, если $d=0$. 	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Протокол выполнения стандартной программы}
	
	\includegraphics[width=1\textwidth]{content/schemas1/standard_program_protocol.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Рабинович Е.В. Теория вычислительных процессов. \textbf{Раздел ``Стандартные схемы''}.
	\item Котов В.Е., Сабельфельд В.К. Теория схем программ. - М.: Наука, 1991. - 248 с. \textbf{сс.1-91}.
\end{itemize}
\end{slide}

