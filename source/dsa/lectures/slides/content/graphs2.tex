Хакасский государственный университет им. Н.Ф. Катанова\newline
Структуры и алгоритмы обработки данных\newline
\title{Лекция: Графы: сильно связанные компоненты, остовные деревья.}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Проблема связности}
	
	В коммуникационных и транспортных сетях важно знать, что любой узел сети доступен из любого другого узла.
	
	Орграф называется \textbf{сильно связным}, если для каждой пары вершин $u,v \in V$ существует путь из $v$ в $u$ и обратно.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Сильно связный компонент} графа $G$ есть сильно связный подграф графа $G$, причем в него входят максимально возможное количество вершин, для которых существуют пути туда и обратно.
	
	\includegraphics[width=0.7\textwidth]{content/graphs/strong_components.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Сильно связные компоненты и DFS}
	
	\includegraphics[width=0.9\textwidth]{content/graphs/strong_components_dfs.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Поиск сильно связных компонентов}
	\begin{codebox}
	\Procname{$\proc{FindStrongComp}(G)$}
	\li $DFS(G)$ \Comment вычислим $f[u]$ для каждой вершины $u$
	\li $R \gets Reverse(G)$ \Comment инвертируем все ребра в $G$
	\li $SortByF(R)$ \Comment сортируем вершины в $R$ по $f[u]$ по убыванию 
	\li $DFS(R)$
	\End
	\end{codebox}
	
	\textbf{Результат:} каждое DFS-дерево в $R$ яляется сильно связным компонентом.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм поиска сильно связных компонетов}
	
	\includegraphics[width=1\textwidth]{content/graphs/strong_components_example.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Доказательство теоремы на семинар:}
	
	Процедура $FindStrongComp(G)$ корректно вычисляет сильно связные компоненты ориентированного графа $G$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Проблема построения сети}

	Области возникновения: коммуникационные и дорожные сети. 
	
	
	\textbf{Дано:} множество узлов сети (хосты, города).
	
	\textbf{Необходимо:} построение сети с наименьшим общим весом ребер (длина сетевых кабелей, длина дорог).
	
	\textbf{Графовая модель}: узлы сети являются узлами графа, $E=V^2$, нам известны веса всех ребер.
	
	\textbf{Результат}: свободное дерево.
\end{slide}


% ----------------------------------------------------------------
\begin{slide}
	\textbf{Минимальное дерево Стайнера}
	
	\includegraphics[width=1\textwidth]{content/graphs/steiner_mt.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Минимальное остовное дерево}
	
	\textbf{Остовное дерево} - ацикличный подграф $G1=(V1,E1,w1)$ графа $G=(V,E,w)$, где $E1 \subseteq E, V1=V, w1=w$.
	
	\textbf{Минимальное остовное дерево} - остовное дерево с минимальным весом. $\displaystyle w(G) = \sum_{(u,w) \in E}{w(u,w)}$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Примеры остовных деревьев}
	
	\includegraphics[width=1\textwidth]{content/graphs/st_examples.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Подход к поиску МОД}

	Строим дерево путем добавления по одному ребру, и перед каждой итерацией текущее дерево является подмножеством некоторого МОД.
	
	\begin{codebox}
	\Procname{$\proc{GenericMST}(G,w)$}
	\li $A \gets 0$
	\li \While $A$ не является МОД 
	\li \Do Найти безопасное для $A$ ребро $(u,v)$
	\li $A \gets A \bigcup \{(u,v)\}$ \End
	\li \Return $A$
	\End
	\end{codebox}
		
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Разрез} $(S, V - S)$ неориентированного графа $G=(V,E)$ есть разбиение множества вершин графа.
	
	\includegraphics[width=0.4\textwidth]{content/graphs/mst_cut.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	Ребро $(u,v) \in E$ \textbf{пересекает} разрез $(S, V - S)$, если один из его концов находится в $S$, а другой в $V-S$.
	
	Разрез \textbf{согласован} с множеством $A$ по ребрам, если ни одно ребро из $A$ не пересекает разрез.
	
	Ребро, пересекающее разрез, является \textbf{легким}, если оно имееит минимальный вес среди всех ребер, пересекающих разрез.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Теорема}
	
	Пусть $G=(V,E)$ - связный неориентированный граф с действительной весовой функцией $w$, определенной на $E$. Пусть $A$ - подмножество $E$,
	которое входит в некоторое минимальное остовное дерево $G$, $(S,V-S)$ - разрез $G$, согласованный с $А$ по ребрам, а $(u,v)$ - легкое ребро, пересекающее разрез
	$(S, V-S)$. Тогда ребро $(u,v)$ является безопасным для $A$.
	
	Доказательство на семинар.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Крускала}
	
	\includegraphics[width=1\textwidth]{content/graphs/mst_kruskal_listing.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Крускала - процедуры}
	
	$Create-Set(u)$ - создать множество из одной вершины $u$.
	
	$Find-Set(u)$ - найти множество, которому принадлежит вершина $u$.
	
	$Union(u, v)$ - объединить множества, которые содержат вершины $u$ и $v$.
	
	\textbf{Структуры данных для хранения непересекающихся подмножеств на семинар.}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Крускала}
	
	\includegraphics[width=1\textwidth]{content/graphs/mst_kruskal_example.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Анализ алгоритма Крускала}
	
	$E \geq V$, так как граф связный.
	
	Создание множеств - $\Theta(V \cdot \alpha V) = \Theta(V log V) = \Theta(E log E)$
	
	Сортировка ребер - $\Theta(E log E)$.
	
	Цикл выполняется $E$ раз.
	
	Поиск и объединение множеств - $\Theta(\alpha V) = \Theta(log V) = \Theta(log E)$
	
	$T(G) = \Theta(E log E)$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Прима: идея}
	
	\includegraphics[width=1\textwidth]{content/graphs/mst_prim_idea.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Прима}
	
	\includegraphics[width=0.9\textwidth]{content/graphs/mst_prim_listing.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Прима: пример}
	
	\includegraphics[width=1\textwidth]{content/graphs/mst_prim_example.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Прима: анализ}
	
	$\displaystyle T(G) = V + V log V + \sum_{u \in V}(log V + deg(u) log V) = V + V log V + (V+2E) log V = \Theta(E log V)$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{На семинар}
	
	Алгоритм Барувки (Baruvka)

\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item David M. Mount, The Lecture notes: Design and Analysis of Computer Algorithms. [Электронный ресурс] / Dept. of Computer Science, University of Maryland, 2004. - Режим доступа: http://www.cs.umd.edu/~mount/451/Lects/451lects.pdf . - \textbf{сс.39-49}
	\item Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ, 2-е издание. - М. : Издательский дом ``Вильямс'', 2007. \textbf{сс.644-662}.
\end{itemize}
\end{slide}

