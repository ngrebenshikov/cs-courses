Хакасский государственный университет им. Н.Ф. Катанова\newline
Структуры и алгоритмы обработки данных\newline
\title{Лекция: Методы программирования.}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Методы программирования}
	
	\begin{itemize}
		\item \textbf{Жадные алгоритмы} - производится локально оптимальный выбор в надежде, что он приведет к оптимальному решению глобальной задачи.
		\item \textbf{Динамическое программрование} - разбить большую задачу на подзадачи и не вычислять подзадачи более одного раза (использовать память).
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Жадные алгоритмы}
	
	\begin{itemize}
		\item Не всегда дают оптимальный результат. Например, раскраска графа.
		\item Также являются жадными: алгоритмы поиска минимального остовного дерева, алгоритм Дейкстры, алгоритм Хаффмана.
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о выборе процессов}
	
	\textbf{Дано:} множество процессов $S=\left\{a_1,a_2,\ldots,a_n\right\}$, процессам требуется некоторый ресурс, который одновременно может использоваться лишь одним процессом. 
	Каждый процесс $a_i$ характеризуется \textbf{начальным моментом} $s_i$ и конечным моментом $s_i$, где $0 \leq s_i < f_i < \infty$. Будучи выбран, процесс $a_i$ длится
	в течение $\left[s_i,f_i\right)$, а процессы $a_i$ и $a_j$ \textbf{совместимы}, если интервалы $\left[s_i,f_i\right)$ и $\left[s_j,f_j\right)$ не перекрываются.
	
	\textbf{Найти:} подмножество взаимно совместимых процессов, образующих множество максимального размера.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о выборе процессов. Оптимальное решение.}
	
	Пусть $S$ отсортировано по $f$ в порядке возрастания.
	
	$A_{ij} = \left\{s_k \in S : f_i \leq s_k < f_k \leq s_j\right\}$ - подмножество процессов, 
	которые можно выполнить в промежутке между завершением $a_i$ и началом $a_j$
	
	Оптимальное решение задачи $S_{ij}$ равно $A_{ij} = A_{ik} \bigcup {a_k} A_{kj}$.
	
	$c[i,j] = \begin{cases} 
		0, & \mbox{при } S_{ij} = \oslash \\
		\displaystyle max_{i < k < j, a_k \in S_{ij}}\left\{c[i,k] + c[k,j] + 1\right\}, & \mbox{при } S_{ij} \neq \oslash 
	\end{cases}$ 
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о выборе процессов. Жадный алгоритм.}
	
	\includegraphics[width=1\textwidth]{content/common_methods/schedule_listing.png}	
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о выборе процессов. Жадный алгоритм.}
	
	\includegraphics[width=0.8\textwidth]{content/common_methods/schedule_example.png}	
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о выборе процессов}
	
	$T(n) = \Theta(N log N)$. Почему?
	
	Доказательство оптимальности:
	
	\includegraphics[width=1\textwidth]{content/common_methods/schedule_optimal.png}	
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о рюкзаке.}
	
	\includegraphics[width=1\textwidth]{content/common_methods/knapsack_example.png}	
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Жадный метод}
	
	\begin{enumerate}
		\item Привести задачу оптимизации к виду, когда после сделанного выбора остается решить только одну поздзадачу.
		\item Доказать, что существует оптимальное решение, которое можно получить жадным выбором и такой выбор всегда допустим.
		\item Показать, что после жадного выбора остается подзадача, которую можно решить жадным методом.
	\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{На семинар}
	
	\begin{itemize}
		\item Теоретические основы жадных алгоритмов.
		\item Задача планировки заданий, выполняющихся на одном процессоре.
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Динамическое программирование} - применяется если подзадачи не являются независимыми.
	
	\begin{enumerate}
		\item Описание структуры оптимального решения.
		\item Рекурсивное определение значения оптимального решения.
		\item Вычисление значения с помощью восходящего анализа.
		\item Составление оптимального решения на основе информации, полученной предыдущих этапах.
	\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Числа Фиббоначи}
	
	$F(n) = \begin{cases} 
		1, & \mbox{при } n = 1, n = 2 \\
		f(n-1) + f(n-2), & \mbox{при } n > 2
	\end{cases}$
	
	$T_{recursive}(n) = O(2^n)$
	
	$T_{table}(n) = O(n)$ - это и есть динамическое программирование.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Дискретная задача о рюкзаке}
	
	\textbf{Дано:} $N$ предметов $\left\{x_1,x_2,\ldots,x_N\right\}$ с различной стоймостью $V_i$ и весом $W_i$, максимальный вес $W_{max}$.
	
	\textbf{Найти:} подмножество предметов, вес которых бы не привышал $W_{max}$, стоймость которых была бы максимальной.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Дискретная задача о рюкзаке. Описание структуры}
	
	$C_{iw}$ - максимальная стоимость предметов из множества \newline	$\left\{x_1,x_2,\ldots,x_i\right\}$ при максимальном весе равном $w$.
	
	$C_{iw} = \begin{cases} 
		0, & \mbox{если } i=0 \vee w=0 \\
		C_{(i-1)w}, & \mbox{если } W_i > w \\
		max(C_{(i-1)w}, C_{(i-1)(w-W_i)} + V_i & \mbox{если } W_i \leq w
	\end{cases}$
	
	Ответ: $C_{NW}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Дискретная задача о рюкзаке. Алгоритм.}
	
\begin{lstlisting}[frame=single,emph={output},emphstyle=\underbar]
for (i=0;i<=N ;i++) C[i][0] = 0;
for (w=0;w<=Wmax;w++) C[0][w] = 0;

for (i=1;i<=N;i++)
  for (w=1;w<=Wmax;w++) {
    if (Wi[i] > w)
      C[i][w] = C[i-1][w];
    else
      C[i][w] = max(C[i-1][w] , C[i-1][w-Wi[i]]+Vi[i]);
  }

output(C[N][Wmax]);
\end{lstlisting}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Дискретная задача о рюкзаке. Анализ алгоритма.}
	
	$T(N,W_max) = \Theta(N \cdot W_max)$ 
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Отличие строк. Edit distance problem}
	
	\textbf{Дано:} две строки, стоимость удаления, вставки и замены символа.
	
	\textbf{Найти:} минимальное количество действий необходимых для преобразования одной строки в другую.
	
	\textbf{Применение:} сравнение ДНК.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Отличие строк. Описание структуры}
	
	$d(s_1,s_2)$ - количество действий по переобразованию строки $s_1$ в $s_2$.
	
	$d(s1, s2) = \begin{cases} 
		0, & \mbox{если } s_1=<> \vee s_2=<> \\
		|s|, & \mbox{если } \begin{array}{l} (s_1=<> \wedge s_2=s) \vee \\ (s_1=s \wedge s_2=<>)\end{array}\\
		\begin{array}{l}
			min(d(\hat{s_1}, \hat{s_2} \\
			+ if(c_1=c_2) 0 else 1), \\
			d(s_1, \hat{s_2}),\\
			d(\hat{s_1}, s_2)) \end{array}
			& \mbox{если } s_1 = \hat{s_1} + c_1, s_2 = \hat{s_2} + c_2
	\end{cases}$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Отличие строк. Алгоритм.}
	
m[0..|s1|,0..|s2|]\newline
m[i,j] = d(s1[1..i], s2[1..j]).


\begin{lstlisting}[frame=single,emph={output},emphstyle=\underbar]
m[0][0] = 0;
for (i=1; i<length(s1); i++) m[i][0] = i;
for (j=1; j<length(s2); j++) m[0][j] = j;

for (i=0; i<length(s1); i++)
  for (j=0; j<length(s2); j++) {
    val = (s1[i] == s2[j]) ? 0 : 1;
    m[i][j] = min( m[i-1][j-1] + val,
                   min(m[i-1][j]+1 , m[i][j-1]+1));
  }
\end{lstlisting}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Отличие строк. Анализ алгоритма.}
	
	$T(s_1, s_2) = \Theta(|s_1| \cdot |s_2|)$ 
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{На семинар}
	
	\begin{itemize}
		\item Задача составления расписания конвейера.
		\item Задача перемножения цепочки матриц.
		\item Поиск самой длинной общей подпоследовательности.
		\item Построение оптимального бинарного дерева поиска.
		\item Задача оптимальной триангуляции многоугольника.
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Лабораторная работа}
	
	В далекой стране Тарватии разгорелся бензиновый кризис. Вследствие чего цены на топливо в каждом городе отличались в значительной степени. В это время принц Педро Де Ля Вега решил проехать по своей стране на автомобиле. Он проложил маршрут, так что ну пути его следования будут находиться $N$ городов. В каждом из этих городов есть заправочные станции. Агенты принца сообщили ему стоимость бензина в каждом из городов. Помогите, пожалуйста, Педро выбрать в каких городах ему заправиться, чтобы потратить на бензин как можно меньше денег. Примите во внимание, что принц всегда заправляет полный бак.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item David M. Mount, The Lecture notes: Design and Analysis of Computer Algorithms. [Электронный ресурс] / Dept. of Computer Science, University of Maryland, 2004. - Режим доступа: http://www.cs.umd.edu/~mount/451/Lects/451lects.pdf . - \textbf{сс.11-25}
	\item Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ, 2-е издание. - М. : Издательский дом ``Вильямс'', 2007. \textbf{сс.386-481}.
\end{itemize}
\end{slide}
