Хакасский государственный университет им. Н.Ф. Катанова\newline
Структуры и алгоритмы обработки данных\newline
\title{Лекция: Поиск подстрок.}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задачи на строках}
	
	Основное приложение: вычислительная молекулярная биология (расшифровка ДНК).
	
	\begin{itemize}
		\item Поиск внутренних паттернов. Например, построение префиксного дерева.
		\item Поиск частных паттернов. Например, поиск подстроки, растояния преобразования, наибольшей общей подпоследовательности, совпадения с регулярным выражением.
		\item Поиск характеристических паттернов. Например, поиск кратных подстрок.
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Поиск подстрок}
	
	\textbf{Дано:} Текст в виде массива $T[1..n]$ и образец в виде массива $P[1..m]$, где $m \leq n$. Элементы массивов $P$ и $T$ - символы из конечного алфавита $\Sigma$.
	Говорят, что $P$ \textbf{\textit{встречается}} в $T$ со \textbf{\textit{сдвигом}} $s$, если $0 \leq s \leq n - m$ и $T[s+1..s+m] = P[1..m]$.
	
	\textbf{Найти:} Все допустимые сдвиги с которыми образец $P$ встречается в тексте $T$.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Терминология}
	
	$\Sigma^*$ - множество всех строк конечной длины, образованных с помощью символов алфавита $\Sigma$.
	
	$\epsilon$ - пустая строка.
	
	$xy$ - конкатенация двух строк.
	
	$w \sqsubset x$ - $w$ является префиксом строки $x$, то есть $\exists y \in \Sigma^*$, что $x=wy$.

	$w \sqsupset x$ - $w$ является суффиксом строки $x$, то есть $\exists y \in \Sigma^*$, что $x=yw$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Лемма о перекрывающихся суффиксах}
	
	Пусть $x, y, z$ - строки, для которых выполняются соотношения $x \sqsupset z$ и $y \sqsupset z$.
	
	Если $|x| \geq |y|$, то $x \sqsupset y$.

	Если $|x| \leq |y|$, то $y \sqsupset x$.

	Если $|x| = |y|$, то $x = y$.
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Простейший алгоритм поиска подстрок}

	\begin{codebox}
	\Procname{$\proc{NaiveStringMatcher}(T,P)$}
	\li $n \gets length[T]$
	\li $m \gets length[P]$
	\li \For $s \gets 0$ \To $n-m$
	\li \Do \If $P[1..m] = T[s+1..s+m]$
	\li \Then $print(s)$ \End \End
	\end{codebox}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Простейший алгоритм поиска подстрок}

	\includegraphics[width=1\textwidth]{content/strings/naive_example.png}	
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Анализ - простейшего алгоритма поиска подстрок}

	Наихудший случай: $T = a^n, P=a^m$
	
	$T(n) = \Theta((n-m+1)m)$
	
	При $m=n/2$ $T(n)=\Theta(n^2)$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Рабина-Карпа}
	
	\textbf{Идея:} использовать хэш-функцию опеределенную на множестве строк.
	
	$h(S[1..k]) = (S[k] + d(S[k-1] + \ldots + d(S[2] + dS[1]) \ldots )) mod\:q$, где $d$ - основание системы, $q$ - модуль.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Рабина-Карпа}

	$h(P[1..m])$ - хэш образца.
	
	$\left\{s : h(P[1..m]) = h(T[s..s+m]) \wedge 0 \geq s \geq n-m\right\}$	- множество допустимых сдвигов. 
	
	Обозначим $t_s = h(T[s..s+m])$, 
	
	тогда $t_{s+1} = (d(t_s - T[s+1]g) + T[s+m+1]) \: mod \: q$, 
	
	где $g \equiv d^{m-1} (mod\:q)$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Рабина-Карпа}
	
	\includegraphics[width=0.7\textwidth]{content/strings/rabin_karp_example1.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм Рабина-Карпа}
	
	\includegraphics[width=1\textwidth]{content/strings/rabin_karp_example2.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Проблема алгоритма Рабина-Карпа}
	
	Из равенства $h(P) = t_s$ не следует, что $P = T[s..s+m]$.
	
	Решение проверить сдвиг $s$ посимвольным сравнением.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\includegraphics[width=1\textwidth]{content/strings/rabin_karp_listing.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Анализ алгоритма Рабина-Карпа}
	
	В наихудшем случае $T(n,m) = \Theta(m) + \Theta((n-m+1)m)$.
	
	Почему?
	
	В общем случае $T(n,m) = O(n) + O(m(v + n/q))$, где $v$ - количество допустимых сдвигов и $q$ - модуль хэш-функции.
	
	Если $v = O(1) \wedge q \geq m \Rightarrow T(n,m) = O(m+n) = O(n)$, так как $n \geq m$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Конечные автоматы}
	
	$M = (Q, q_0, A, \Sigma, \delta)$
	
	$Q$ - конечное множество состояний,
	
	$q_0 \in Q$ - начальное состояние,
	
	$A \subseteq Q$ - конечное множество допустимых состояний,
	
	$\Sigma$ - конечный входной алфавит,
	
	$\delta$ - функция переходов $Q \times \Sigma \rightarrow Q$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Конечные автоматы}
	
	\includegraphics[width=0.5\textwidth]{content/strings/dfa_example1.png}	
	
	$\phi$ - функция конечного состояния.
	
	$\phi(\epsilon) = q_0$

	$\phi(wa) = \delta(\phi(w),a)$ для $w \in \Sigma^*, a \in \Sigma$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Конечный автомат для поиска подстрок}
	
	$\sigma(x) = max\{k : P_k \sqsupset x\}$, где $P_k \sqsubset P \wedge |P_k|=k$ - суффиксная функция
	
	Пример, $P=ab, \sigma(\epsilon)=0, \sigma(ccaca)=1, \sigma(ccab)=2$.
	
	\textbf{Правила построения автомата:}
	
\begin{enumerate}
	\item $Q = \{0,1,\ldots m\}, q_0 = 0, A=\{m\}$
	\item $\delta(q,a)=\sigma(P_qa)$ 
\end{enumerate}
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Конечный автомат для образца $P=ababaca$}

	\includegraphics[width=0.9\textwidth]{content/strings/dfa_example2.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм поиска подстроки с помощью конечного автомата}

	\includegraphics[width=1\textwidth]{content/strings/dfa_listing1.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Алгоритм вычисления функции переходов}

	\includegraphics[width=0.7\textwidth]{content/strings/dfa_listing2.png}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Анализ применения конечных автоматов для поиска подстроки}
	
	Вычисление функции переходов - $T(n,m) = O(m^3|\Sigma|)$. Существуют алгоритмы - $T(n,m) = O(m|\Sigma|)$
	
	Поиск подстроки - $T(n,m) = \Theta(n)$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{На семинар и рефераты}
	
\begin{itemize}
	\item Поиск наибольшей общей последовательности.
	\item Алгоритмы поиска подстрок: Кнута-Морриса-Пратта, Бойера-Мура, Демелки-Бейза-Ятса-Гоннета, Бойера-Мура-Хоспула, Бойера-Мура-Санди, Бойера-Мура-Гелила.
	\item Алгоритмы вычисления растояния ммежду строками: Вагнера-Фишера, Хешберга, Ханта-Шиманского, Укконена-Майерса.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{На семинар и рефераты}
	
\begin{itemize}
	\item Алгоритмы для поиска по регулярным выражениям.
	\item Алгоритмы вычисления периодичности: Крочемора, Мейна-Лоренца, Колпакова-Кучерова.
	\item Алгоритмы построения суффиксных деревьев: Укконена, Вайнера, Мак-Крейга.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ, 2-е издание. - М. : Издательский дом ``Вильямс'', 2007. \textbf{сс.1017-1046}.
	\item Смит, Билл. Методы и алгоритмы вычислений на строках. - М.: ООО ``И.Д. Вильямс'', 2006.
	\item Гасфилд, Дэн. Строки, деревья и последовательности в алгоритмах: Информатика и вычислительная биология. - СПб.: Невский Диалект; БХВ-Петербург, 2003.
\end{itemize}
\end{slide}
