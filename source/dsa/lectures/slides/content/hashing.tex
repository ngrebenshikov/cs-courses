Хакасский государственный университет им. Н.Ф. Катанова\newline
Структуры и алгоритмы обработки данных\newline
\title{Лекция: Поиск. Хеширование}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Скорость поиска}

\begin{itemize}
	\item Линейный поиск - $T_{prepare} = O(n), T{find} = O(n)$
	\item Бинарный поиск и деревья поиска - 
	
	$T_{prepare} = O(n \cdot log(n)), T{find} = O(log(n))$
	\item Но хочется быстрее - можно ли искать за $O(1)$
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Прямой доступ}
	
	Если ключи $\in \{0, 1, \ldots, m-1\}$ и различны, то множество $S$ можно представить в виде массива $T[0..m-1].$
	
	$T[k] = \displaystyle\left\{\stackrel{x, x \in S \wedge key[x]=k}{null, otherwise}\right.$
	
	Операция поиска по ключу занимает время $O(1)$

\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Более сложные ключи}
	
	Пусть, количество элементов в множестве ограничено небольшим числом.
	
	Проблемы возникают, когда:
	\begin{itemize}
		\item возможные ключи принадлежат большому множеству? Например, $\{0,1, \ldots, 10^9\}$
		\item ключи не являются числами? Например, строки.
	\end{itemize}
\end{slide}


% ----------------------------------------------------------------
\begin{slide}
	\textbf{Хеширование}

	\textbf{Хеш-функция} - такая функция $h$, которая определяет местоположение элементов множества $S$ в таблице $T$.
	
	\includegraphics[width=0.6\textwidth]{content/hashing/hash_func.pdf}
	
	$x.key \in A \Rightarrow h(x.key) = k$
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Коллизии}

	$|A| > 1 \Rightarrow $ Коллизия. Например, $h(43)=h(89)=h(112)=k$
	
	Решения коллизий:
	
\begin{itemize}
	\item Метод цепочек
	\item Открытая адресация
\end{itemize}
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Метод цепочек}
	
	Идея: Хранить элементы множества с одинаковым значением хэш-функции в виде списка.
	
	\includegraphics[width=0.6\textwidth]{content/hashing/chain.pdf}
	
	$h(51) = h(49) = h(63) = i$
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Анализ метода цепочек}
		
	\begin{itemize}
		\item \textbf{Наихудший случай:} если хэш-функция для всех элементов множества выдает одно и то же значение. \newline
			Время доступа равно $\Theta(n)$, при $\left|S\right|=n$.
		\item \textbf{Средний случай:} для случая, когда значения хэш-функции равномерно распределены. Каждый ключ с равной вероятностью может попасть в любую ячейку таблицы, вне зависимости от того куда попали другие ключи.\newline
			Время доступа?
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Коэффициент заполненности хэш-таблицы}
	
	Пусть дана таблицы $T[0..m-1]$, и в ней хранится $n$ ключей.
	
	Тогда, $\alpha = n/m = $ среднее количество ключей в ячейках таблицы.
	
	\textbf{Математическое ожидание времени поиска, закончившегося неудачей} $= \Theta(1 + \alpha)$ (вычисление значения хэш-функции + просмотр списка).
	
	$M[T(n)] = \Theta(1)$, если $\alpha = O(1) \Leftrightarrow n = O(m)$ 
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Выбор хэш-функции}
	\begin{itemize}
		\item Ключи должны равномерно распределяться по всем ячейкам таблицы
		\item Закономерность распределения ключей хэш-функцией не должна коррелировать с закономерностями данных. (Например, данные - это четные числа).
	\end{itemize}
	\textbf{Методы:}
	\begin{itemize}
		\item Метод деления
		\item Метод умножения
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Метод деления}
	
	$h(k) = k \;mod\; m$
	
	Проблема маленького делителя $m$:
	
	Пример №1. $d=2$ и все ключи четные $\Rightarrow$ нечетные ячейки не заполнены.
	
	Пример №2. $m = 2^r$ $\Rightarrow$ хэш не зависит от битов выше $r$.
\end{slide}


% ----------------------------------------------------------------
\begin{slide}
	\textbf{Метод деления: хорошая эвристика}
	
	Выбирать для $m$ простое число не близкое к степеням 2 и 10.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Метод умножения}
	
	Пусть $m=2^r$, ключи являются $w$-битными словами.
	
	$h(k) = (A \cdot k \; mod \; 2^w) >> (w - r)$, где
	
	$A \; mod \; 2 = 1 \ \wedge \  2^{w-1} < A < 2^w$
	
	\begin{itemize}
		\item Не следует выбирать $A$ близко к $2^{w-1}$ и $2^w$
		\item Данный метод быстрее метода деления
	\end{itemize}
\end{slide}
	
% ----------------------------------------------------------------
\begin{slide}
	\textbf{Метод умножения: пример}
	
	$m = 8 = 2^3, w=7$
	
\begin{tabular}[t]{| c | c | c | c | c | c | c | c | c | c | c | c | c | c | r | r |}
	\hline 
	 &  &  &  &  &  &  & 1 & 0 & 1 & 1 & 0 & 0 & 1 & A\\ 
	\hline
	 &  &  &  &  &  &  & 1 & 1 & 0 & 1 & 0 & 1 & 1 & k\\ 
	\hline
	1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & \\ 
	\hline
\end{tabular}	
	
	$\underbrace{1001010}_{ignore \; by \; mod \; 2^w} \ \ \ \underbrace{011}_{h(k)} \ \ \ \underbrace{0011}_{ignore \; by \; >> (w-r)}$
\end{slide}
	
% ----------------------------------------------------------------
\begin{slide}
	\textbf{Колесо остатков}
	
	$k \in \{1,2,3\}$

	\includegraphics[width=0.4\textwidth]{content/hashing/modular_wheel.pdf}
	
\end{slide}

	
% ----------------------------------------------------------------
\begin{slide}
	\textbf{Разрешение коллизий: открытая адресация}

	\begin{itemize}
		\item Не нужно хранить ссылки.
		\item Будем последовательно проверять ячейки таблиц, пока не найдем пустую.
		\item $h : U \times \{0,1,\ldots,m-1\} \rightarrow \{0,1,\ldots,m-1\}$
		\item $\left\langle h(k,0),h(k,1),\ldots,h(k,m-1)\right\rangle$ - это перестановка $\left\langle0,1,\ldots,m-1\right\rangle$
		\item $n \leq m$
	\end{itemize}
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Открытая адресация: пример вставки}

Пусть дана таблица $A$:

\begin{tabular}[t]{| c | c | c | c | c | c | c | c | c | c | c |}
	\hline
	1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\ 
	\hline
	 & 23 & 45 &  &  & 78 &  &  &  & \\ 
	\hline
\end{tabular}	

Вставим $k=89$:
\begin{enumerate}
	\item $h(89,0) = 3$
	\item $h(89,1) = 2$
	\item $h(89,2) = 9$ - \textbf{Успех!}
\end{enumerate}
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Открытая адресация: поиск}

	\begin{itemize}
		\item Поиск - также последовательное исследование.
		\item Успех, когда нашли значение.
		\item Неудача, когда нашли пустую клетку или прошли всю таблицу.
	\end{itemize}
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Стратегии исследования}

	\begin{itemize}
		\item Линейная - $h(k,i) = (h(k,0) + i) \; mod \; m$. \newline Плохо работает для заполненных областей ячек.
		\item Двойное хэширование - $h(k,i) = (h_1(k) + i \cdot h_2(k)) \; mod \; m$. 
			\newline Обычно выбирают $m=2^r$ и $h_2(k)$ - нечетной.
	\end{itemize}
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Анализ открытой адресации}

	Дополнительное допущение для равномерного хэширования: каждый ключ может равновероятно получить любую из $m!$ перестановок последовательностей исследования таблицы независимо от других ключей..
	
	\textbf{Теорема.} $E[$количество исследований$] \leq \frac{1}{1-\alpha}$, 
	\newline где $\alpha < 1 \Longleftrightarrow n < m$

\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Доказательство (неудачный поиск)}
	
	\begin{itemize}
		\item Одно исследование всегда нужно. С вероятностью $n/m$ будет выявлена коллизия. 
			\newline $\Rightarrow (n-1)/(m-1) \Rightarrow \ldots \Rightarrow (n-i)/(m-i) \Rightarrow \ldots$
		\item Заметим, что $\frac{n-i}{m-i} < \frac{n}{m} = \alpha$ для $i \in \{1,2,3,\ldots,n-1\}$
		\item $E[\#probes] = 1 + \frac{n}{m}(1 + \frac{n-1}{m-1}(1 + \frac{n-2}{m-2}(\ldots \frac{1}{m-n}\ldots)))$
			\newline $\leq 1 + \alpha(1 + \alpha(1 + \alpha(1 + \alpha( \ldots 1 + \alpha \ldots))))$
			\newline $\leq 1 + \alpha + \alpha^2 + \alpha^3 + \ldots$
			\newline $\displaystyle = \sum_{i=0}^{\infty}\alpha^i$
			\newline $ = \frac{1}{1-\alpha}$
	\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Скорость работы поиска в хэш-таблице при открытой адресации}

	$\alpha < 1 - const \Rightarrow O(1)$
	
	Как же себя ведет $\alpha$:
	
	\begin{itemize}
		\item Таблица заполнена на 50\% $\Rightarrow$ 2 исследования
		\item Таблица заполнена на 90\% $\Rightarrow$ 10 исследований
		\item Таблица заполнена на 100\% $\Rightarrow$ m исследований
	\end{itemize}
	 
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Ахо А., Хопкрофт Д., Ульман Д. Структуры данных и алгоритмы. - М. : Издательский дом ``Вильямс'', 2000. \textbf{сс.116-127}.
	\item Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ, 2-е издание. - М. : Издательский дом ``Вильямс'', 2007. \textbf{сс.282-315}.
\end{itemize}
\end{slide}
