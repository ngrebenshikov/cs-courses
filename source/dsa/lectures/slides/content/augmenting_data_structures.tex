Хакасский государственный университет им. Н.Ф. Катанова\newline
Структуры и алгоритмы обработки данных\newline
\title{Лекция: Расширение структур данных.}
\date{}
\author{Николай Гребенщиков, www.grebenshikov.ru}
\maketitle

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Стандартных структур данных достаточно?}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Жизнь сложнее, чем стандартные структуры данных.}
	
\begin{itemize}
	\item Создание новых структур данных.
	\item Расширение стандартных структур данных.
\end{itemize}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о перекрывающихся отрезках на прямой}
	
	\textbf{Отрезки на прямой} - события, которые занимают некоторый промежуток времени.
	
	\textbf{Задача:} найти все события, которые происходили в заданный промежуток времени.

\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Задача о перекрывающихся отрезках на прямой}
	
	\textbf{Отрезок} - $[t_1,t_2] \equiv \{t \in R : t_1 \leq t \leq t_2\}$, где $t_1 \leq t_2$
	
	Два отрезка $i$ и $j$ \textbf{перекрываются}, если $i \bigcap j \neq \oslash$.
	
	Представим отрезок $[t_1,t_2]$ в виде объекта $i$ с полями $loq[i]=t_1$ и $high[i]=t_2$.
	
	Тогда два отрезка $i$ и $j$ перекрываются, если $low[i] \leq high[j]$ и $low[j] \leq high[i]$.
	
	\textbf{Задача:} найти все отрезки, которые перекрываются с заданным.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Трихотомия отрезков}
	
	\begin{enumerate}
		\item $i$ и $j$ перекрываются;
		\item $i$ находится слева от $j$, т.е. $high[i] < low[j]$;
		\item $i$ находится справа от $j$, т.е. $high[j] < low[i]$;
	\end{enumerate}
\end{slide}


% ----------------------------------------------------------------
\begin{slide}
	\textbf{Трихотомия отрезков}
	
	\includegraphics[width=1\textwidth]{content/augmenting_data_structures/three_intervals.png}

\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{АТД ``Множество отрезков''}

\begin{lstlisting}[frame=single,emph={insert, delete, search},emphstyle=\underbar]
interface IntervalSet {
	void insert(Interval i);
	void delete(Interval i);
	Collection<Interval> search(Interval i);
}
\end{lstlisting}	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Расширение структур данных}
	
	\begin{enumerate}
		\item Выбор базовой структуры
		\item Определение необходимой дополнительной информации, которую следует хранить в базовой структуре и поддерживать ее актуальность.
		\item Проверка того, что доп. информация может поддерживаться модифицирующими операциями над базовой структорой.
		\item Разработка новых операций.
	\end{enumerate}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Множество отрезков: выбор базовой структуры}
	
	\textbf{Базовая структура:} сбалансированное дерево поиска, например, AVL-дерево.
	
	Каждый узел $x$ дерева будет содержать отрезок $int[x]$, а ключом будет $low[int[x]]$. 
	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Теорема. Расширение AVL-дерева}
	
	Пусть $f$ - поле, которое расширяет AVL-дерево $T$ из $n$ узлов.
	
	Пусть содержимое поля $f$ узла $x$ может быть вычислено с использованием лишь информации, хранящейся в узлах $x , left[x], right[x]$, включая $f[left[x]]$ и $f[right[x]]$. 
	
	\textbf{В таком случае} мы можем поддерживать актуальность информации $f$ во всех узлах дерева $T$ в процессе вставки и удаления без влияния на асимтотическое время работы данных процедур $O(lg(n))$.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Теорема. Расширение AVL-дерева. Идея доказательства}
	
	Изменение $f[x]$ может потребовать лишь изменение $f[parent[x]]$.
	
	Изменение $f[parent[x]]$ может потребовать лишь изменение $f[parent[parent[x]]]$.
	
	И так по цепочке до корня.
	
	Высота дерева - $O(log(n))$
	
	\textbf{Операция вставки:} вставка узла в AVL-дерево + изменение поля $f$ = $O(log(n)) + O(log(n)) = O(log(n))$.
	
	(Каждый поворот в AVL-дереве затрагивает константное количество узлов)
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Множество отрезков: дополнительная информация}
	
	$max[x]$ - максимум из $high[int[y]]$ для всех $y$ являющихся узлами дерева, где $x$ - корень.	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Множество отрезков: поддержка информации}
	
	$max[x] = max(high[int[x]], max[left[x]], max[right[x]])$
	
	Удовлетворяет ли эта формула предыдущей теореме?	
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Дерево отрезков}
	
\begin{center}
\includegraphics[width=0.7\textwidth]{content/augmenting_data_structures/intervals_tree.png}
\end{center}
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Множество отрезков: разработка новых операций}
	
\begin{center}
\includegraphics[width=0.8\textwidth]{content/augmenting_data_structures/intervals_set_search.png}
\end{center}

Что находит эта функция? 
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
	\textbf{Поиск всех отрезков, которые пересекаются с заданным}

	Попробуем придумать алгоритм с временем выполнения \newline 
	$O(min(n,k \: lg \: n))$, где $k$ - количество найденых отрезков.

	Ваши идеи?	
\end{slide}


% ----------------------------------------------------------------
\begin{slide}
	\textbf{На семинар}

	Задача (перестановка) Иосифа
	
	Задача поиска точки максимального перекрытия отрезков
	
	Специализированные структуры: дерево максимумов, дерево сумм.
\end{slide}

% ----------------------------------------------------------------
\begin{slide}
\textbf{Список литературы}
\begin{itemize}
	\item Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ, 2-е издание. - М. : Издательский дом ``Вильямс'', 2007. \textbf{сс.365-382}.
\end{itemize}
\end{slide}