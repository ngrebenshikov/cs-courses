\begin{lesson}{Деревья}

\setcounter{problem}{0}

В данной работе вам требуется реализовать абстрактные типы ``Дерево'' и ``Бинарное дерево''. Для обхода дерева необходимо реализовать шаблон проектирования ``Visitor''. С использованием этих абстрактных типов решить описанные ниже задачи.

\textbf{Интерфейс действия для шаблона ``Visitor''} 
\begin{lstlisting}
interface Action<T> {
	void doAction(T o);
}
\end{lstlisting}

\textbf{Интерфейс для абстрактного типа ``Дерево''} 
\begin{lstlisting}
interface Tree<T> {
	T getData();
	void setData(T o);
	Tree<T> getLeftMostChild();
	Tree<T> getRightMostChild();
	Tree<T> getLeftSibling();
	void setLeftSibling(Tree<T> sibling);
	Tree<T> getRightSibling();
	void setRightSibling(Tree<T> sibling);
	Tree<T> getParent();
	void setParent(Tree<T> parent);
	void insertChildAsRightMost(Tree<T> child);
	void preOrder(Action<T> a);
	void postOrder(Action<T> a);
	void levelPreOrder(Action<T> a); 
}
\end{lstlisting}

\textbf{Интерфейс для абстрактного типа ``Бинарное дерево''} 
\begin{lstlisting}
interface BinaryTree<T> {
	T getData();
	void setData(T o);

	BinaryTree<T> getParent();
	void setParent(BinaryTree<T> parent);

	void setLeft(BinaryTree<T> value);
	BinaryTree<T> getLeft();
	
	void setRight(BinaryTree<T> value);
	BinaryTree<T> getRight();
}
\end{lstlisting}

\input labs/analysis_task.tex

\begin{problem}{Обходы дерева}{Стандартный поток ввода}{Стандартный поток вывода}{5 секунд}

Дано описание дерева. Вам необходимо найти следующие последовательности узловов данного дерева:

\begin{itemize}
	\item узлы дерева в порядке прямого обхода;
	\item узлы дерева в порядке обратного обхода;
	\item узлы дерева в порядке по-уровневого прямого обхода;
	\item потомки заданного узла;
	\item предки заданного узла.
\end{itemize}

\InputFile

Входной файл содержит описание дерева. В первой строке файла задается число $N$ - количество ребер в дереве. Во второй строке задается натуральное число $R$ - идентификатор корневого элемента. В третьей строке задается натурально число $X$ - идентификатор произвольного узла в дереве. В следующих $N$ строках заданы ребра дерева, по 2 числа $x$, $y$ в строке, означающих, что вершина с номером $y$ является ребенком вершины с номером $x$. О порядке появления ребер в файле можно сказать, что если ребро $(x,y)$ появилось раньше ребра $(x,z)$, то ребенок $y$ находится левее ребенка $z$. $N \ni [0, 5000]; R, X, x, y \ni [0, 10^5]$.

\textbf{Примечание:} каждый узел дерева имеет уникальный идентификатор.
\OutputFile

В выходной файл необходимо вывести пять строк:
\begin{itemize}
	\item в первой строке необходимо через пробел вывести идентификаторы элементов дерева в порядке прямого обхода дерева;
	\item во второй в порядке обратного обхода дерева;
	\item в третьей в порядке по-уровневого прямого обхода дерева;
	\item в четвертой строке необходимо через пробел вывести идентификаторы потомков узла X в порядке прямого обхода;
	\item в пятой строке необходимо вывести через пробел всех предков узла X в порядке от корня дерева к узлу.
\end{itemize}


\Example

\begin{example}
\exmp{
8
5
9
4 9
5 2
9 3
4 7
9 6
5 8
7 1
5 4
}{
5 2 8 4 9 3 6 7 1
1 7 6 3 9 4 8 2 5
5 2 8 4 9 7 3 6 1
3 6
5 4
}%
\end{example}

\end{problem}

\begin{problem}{Префиксные коды}{Стандартный поток ввода}{Стандартный поток вывода}{1 секунда}

Дан язык $L$ с алфавитом $A$. Для кажой буквы $a$ алфавита $A$ известна вероятность $p$ появления этой буквы в словах языка $L$. Вам необходимо найти префиксные коды для каждой буквы заданного алфавита по следующему алгоритму:

\begin{enumerate}
	\item Построить лес деревьев. Каждое дерево состоит из одного узла - буквы алфавита $A$. Весом дерева считаем сумму вероятностей букв находящихся в дереве. Расставить деревья с лева на право в порядке появления символов во входном файле.
	\item Пока существует более одного дерева в лесу, выполняем шаги 3-5.
	\item Найти дерево $T_1$ - дерево с наименьшим весом. (Если существует несколько таких деревьев, то среди них выбираем самое левое). Удалить дерево $T_1$ из леса деревьев, а на его место поместить самое правое дерево.
	\item Найти дерево $T_2$ - дерево с наименьшим весом. (Если существует несколько таких деревьев, то среди них выбираем самое левое).
	\item Создать новое дерево $T$ с левым поддеревом $T_2$ и правым поддеревом $T_1$. Удалить дерево $T_2$ из леса деревьев, а на его место поместить новое дерево $T$.
	\item Префиксным кодом буквы будет являться запись пути от корня дерева до нее, где дуга влево помечается 1, а дуга вправо помечается нулем.
\end{enumerate}

\InputFile

В первой строке входного файла задано число $N$ ($1 \leq N \leq 26$). Следующие $N$ строк содержат вероятности появления букв. Каждая строка состоит из строчной буквы латинского алфавита $a \in [a..z]$ и записанного через пробел значения вероятности $p \in [0,1]$ с максимум 5-ю цифрами после запятой.

\OutputFile

В выходной файл необходимо вывести $N$ строк. Каждая строка должна представлять собой пару ``символ'' ``код''.

\Example

\begin{example}
\exmp{
5
a 0.5
b 0.1
c 0.1
d 0.003
e 0.297}{
a 0
b 1011
c 100
d 1010
e 11
}%
\exmp{
5
a 0.2
b 0.2
c 0.2
d 0.2
e 0.2}{
a 110
b 00
c 10
d 01
e 111
}%
\end{example}

\end{problem}

\end{lesson}