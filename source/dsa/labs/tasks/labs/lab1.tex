\begin{lesson}{Линейные структуры данных}

\setcounter{problem}{0}

В данной работе вам требуется реализовать абстрактные типы стек и очередь.

\textbf{Интерфейс для абстрактного типа стек} 
\begin{lstlisting}
interface Stack {
	void push(String str); // Положить в стек
	String pop(); // Достать из стека
	String top(); // Значение вершины стека
	bool isEmpty(); // Пуст ли стек?
}
\end{lstlisting}
\textbf{Интерфейс для абстрактного типа очередь}
\begin{lstlisting}
interface Queue {
	void push(String str); // Положить в очередь
	String pop(); // Достать из очереди
	String nextValue(); // Значение следующего элемента очереди
	bool isEmpty(); // Пуста ли очередь?
}
\end{lstlisting}

Для описанных выше абстрактных типов данных необходимо сделать две реализации с использованием как последовательного так и связного распределения. У вас должно получиться четыре класса (или наборов стуктур и функций). Например, StackArray, QueueArray, LinkedStack, LinkedQueue. С использованием этих абстрактных типов решить следующие две задачи.

\input labs/analysis_task.tex

\begin{problem}{Скобочные последовательности}{Стандартный поток ввода}{Стандартный поток вывода}{1 секунда}

Вам предлагается определить правильность заданных скобочных последовательностей. Скобочная последовательность считается правильной, если она входит в язык контекстно-свободной грамматики со следующим множеством продукций.
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){.}]
[(period){\\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$\langle$}{$\rangle$}]
<P>:"$\epsilon$".
<P>:"[";<P>;"]".
<P>:"(";<P>;")".
<P>:<P>,<P>.
\end{grammar}

\begin{table}[h]
	\centering
		\begin{tabular}[t]{| p{0.35\textwidth} | p{0.35\textwidth} |}
			\hline
			\textbf{Примеры синтаксически корректных последовательностей} & \textbf{Примеры синтаксически некорректных последовательностей} \\ \hline
			[]
			
			([])
			
			[()[]]()
			
			([([[]])[]](()((()))))
			&
			(
			
			[(])
			
			[()[](])
			
			[([[]])[]]()((())))]
 			\\ 
 			\hline
		\end{tabular}
\end{table}

\InputFile

Входной файл содержит последовательности скобок. Каждая последовательность задана на отдельной строке. Каждая строка состоит из скобок ``(``, ``)'', ``[``, ``]'', и длина ее не менее одного знака и не превышает 255 знаков. Количество скобочных последовательностей не превышает 100.
\OutputFile

В выходной файл необходимо вывести для каждой строки слово ``correct'' , если она является правильной, и слово ``incorrect'' в противном случае.

\Example

\begin{example}
\exmp{
[]
(
[([[]])[]]()((())))]
([])
[()[]]()
([([[]])[]](()((()))))
[(])
[()[](])
}{
correct
incorrect
incorrect
correct
correct
correct
incorrect
incorrect
}%
\end{example}

\end{problem}

\begin{problem}{Буксировка в порту}{Стандартный поток ввода}{Стандартный поток вывода}{1 секунда}

Представьте себе большой морской порт. Перемещение кораблей в таком порту сложная задача, так как требует выполнения ювелирных по точности маневров. Морские корабли не могут решить такую задачу. Ее решают буксиры. В порту количество буксиров ограничено и равно $N$. Корабли буксируются в опрядке появления на рейде. Первый в очереди буксир транспортирует первый пришедший корабль и т.д. Если кораблей на рейде больше $N$, то $N+1$ корабль будет буксировать первый буксир когда освободится, $N+2$ второй и т.д.

Вам необходимо для каждого корабля определить какой буксир его будет транспортировать.

\InputFile

В первой строке входного файла задано число $N$ ($1 \leq N \leq 100$). Следующие $N$ строк содержат названия буксиров в порядке их работы. На $N+2$ строке задано число $M$ - количество кораблей на рейде ($1 \leq M \leq 1000$). Далее на $M$ строках заданы названия кораблей в порядке прибытия на рейд.

Примечание: названия кораблей и буксиров могут состоять из букв английского алфавита пробелов и цифр, и не привышают 255 символов.

\OutputFile

Выходной файл должен содержать $M$ строк. Каждая строка должна содержать название корабля и завание буксира, производящего его транспортировку. Формат строки должен быть следующим ``[Название корабля] - [Название буксира]'' (см. Примеры).

\Example

\begin{example}
\exmp{
2
Haze
Fog
5
Glory
Pallada
Chesma
Diana
Varangian
}{
Glory - Haze
Pallada - Fog
Chesma - Haze
Diana - Fog
Varangian - Haze
}%
\end{example}

\end{problem}

\end{lesson}